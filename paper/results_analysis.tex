\section{結果と分析 (Results and Analysis)}
\label{sec:results_analysis}
本章では、設計したベンチマークに基づき、VOLEitHの性能を多角的に評価する。まず4.1節でVOLEitHプロトコル単体の性能を評価し、既存実装との比較を通じてその基本的な特性を明らかにする。
次に4.2節で、VOLEitHの証明をSNARKで圧縮しオンチェーン検証するまでのエンドツーエンド（E2E）プロセス全体の性能を評価する。最後に4.3節で、これらの結果を統合し、本アーキテクチャ全体の有効性とトレードオフについて考察する。

\subsection{VOLEitH単体性能評価}
VOLEitHプロトコル自体の性能を評価するため、標準的な暗号学的ハッシュ関数であるSHA-256とKeccak-Fの回路を用いてベンチマークを実施した。
これらの回路はBristol Fashion形式で記述されたものを本研究用に変換したものである。

\textbf{表\ref{tab:voleith_standalone_benchmark}}に、Apple M1（メモリ16GB）環境で測定した両回路のベンチマーク結果を示す。

\begin{table}[htbp]
    \centering
    \caption{VOLEitH単体性能ベンチマーク (SHA-256 vs Keccak-F)}
    \label{tab:voleith_standalone_benchmark}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Metric} & \textbf{sha256} & \textbf{keccak\_f} \\
        \hline
        Proof Generation Time & 95 ms & 143 ms \\
        Proof Verification Time & 51 ms & 74 ms \\
        Proof Size & 4,927,342 B (\textasciitilde4.9 MB) & 8,416,569 B (\textasciitilde8.4 MB) \\
        Communication Overhead & 4,927,407 B (\textasciitilde4.9 MB) & 8,416,634 B (\textasciitilde8.4 MB) \\
        Prover Computation Load & 0.02\% CPU, 118.23 MB & 0.04\% CPU, 154.14 MB \\
        Verifier Computation Load & 0.04\% CPU, 138.89 MB & 0.04\% CPU, 158.1 MB \\
        \hline
    \end{tabular}
\end{table}

表\ref{tab:voleith_standalone_benchmark}から、回路の複雑性が性能に直接的な影響を与えることがわかる。
Keccak-FはSHA-256よりも複雑な回路構造を持つため、証明生成時間、検証時間、そして証明サイズのいずれにおいてもSHA-256を上回るコストが必要となった。
特筆すべきは証明サイズであり、SHA-256で約4.9MB、Keccak-Fでは約8.4MBにも達する。この巨大なデータサイズは、そのままではブロックチェーンのブロックサイズ制限やガス代の観点から、オンチェーンでの検証を著しく困難にする。

次に、VOLEitHの性能特性をより明確にするため、既存のZKP実装であるCircom（\cite{eprint:iacr:2023:681}より）によるSHA-256実装との比較を行う。
\textbf{表\ref{tab:sha256_comparison}}に両者の性能比較を示す。

\begin{table}[htbp]
    \centering
    \caption{SHA-256実装の性能比較 (VOLEitH vs Circom)}
    \label{tab:sha256_comparison}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{実装} & \textbf{証明生成時間} & \textbf{証明サイズ} \\
        \hline
        \textbf{VOLEitH (本研究)} & \textbf{95 ms} & \textbf{\textasciitilde4.9 MB} \\
        Circom (先行研究 \cite{eprint:iacr:2023:681}) & \textasciitilde1,473 ms & \textasciitilde821 Bytes \\
        \hline
    \end{tabular}
\end{table}

表\ref{tab:sha256_comparison}は、VOLEitHの基本的なトレードオフを明確に示している。証明生成時間において、VOLEitHはCircom実装の約15.5倍高速である。
これは、証明者の計算効率を重視するVOLEベースのプロトコルの特性を強く反映している。
一方で、証明サイズに目を向けると、VOLEitHの証明は約4.9MBであるのに対し、Circom（Groth16）の証明は約821バイトと、VOLEitHが6000倍以上も大きい。

この結果から、VOLEitHはクライアントデバイスのような計算資源が限られた環境での高速な証明生成には適しているものの、生成された証明はオンチェーン検証には不向きであることがわかる。
この「証明は高速だが、証明自体が巨大」という課題が、本研究でSNARKによる証明圧縮アプローチを採用する動機となった。

\subsection{エンドツーエンド（E2E）性能評価}
前節でVOLEitH単体では証明サイズが大きすぎるという課題が明らかになったため、本節ではVOLEitHの証明をSNARKで圧縮し、オンチェーンで検証するまでのエンドツーエンド（E2E）プロセス全体の性能を評価する。
ベンチマークは、100ゲートおよび1000ゲートのADD回路とAND回路を用いて実施した。

まず、VOLEitHフェーズの性能を\textbf{表\ref{tab:e2e_vole_phase}}に示す。

\begin{table}[htbp]
    \centering
    \caption{E2Eベンチマーク - VOLEフェーズの性能}
    \label{tab:e2e_vole_phase}
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        \textbf{Metric} & \textbf{100 add} & \textbf{100 and} & \textbf{1000 add} & \textbf{1000 and} \\
        \hline
        Proof Gen. Time & 279.012~\ensuremath{\mu\mathrm{s}} & 476.5~\ensuremath{\mu\mathrm{s}} & 790.062~\ensuremath{\mu\mathrm{s}} & 1.649~ms \\
        Proof Ver. Time & 68.75~\ensuremath{\mu\mathrm{s}} & 274.566~\ensuremath{\mu\mathrm{s}} & 585.6~\ensuremath{\mu\mathrm{s}} & 1.082~ms \\
        Proof Size & 21,361 B & 42,491 B & 21,319 B & 233,175 B \\
        Comm. Overhead & 21,426 B & 42,556 B & 21,384 B & 233,240 B \\
        \hline
    \end{tabular}
\end{table}

表\ref{tab:e2e_vole_phase}から、VOLEフェーズにおいては、回路のゲート数が増加するにつれて、証明生成時間、検証時間、証明サイズ、通信オーバーヘッドが増加することがわかる。
特に、ANDゲート回路はADDゲート回路と比較して、同程度のゲート数であっても証明生成時間、検証時間、証明サイズが大幅に増加する傾向にある。
これは、\texttt{soft\_spoken}の実装において、ANDゲートのような乗算処理がADDゲートのような加算処理よりも多くのVOLEプロトコルラウンドや計算を必要とすることに起因すると考えられる。

次に、SNARKフェーズの性能を\textbf{表\ref{tab:e2e_snark_phase}}に示す。このフェーズでは、VOLEitHの証明をSNARK（Groth16）形式に変換し、オンチェーン検証に適した形に圧縮する。

\begin{table}[htbp]
    \centering
    \caption{E2Eベンチマーク - SNARKフェーズの性能}
    \label{tab:e2e_snark_phase}
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        \textbf{Metric} & \textbf{100 add} & \textbf{100 and} & \textbf{1000 add} & \textbf{1000 and} \\
        \hline
        Proof Gen. Time & 272 ms & 1,794 ms & 324 ms & 8,003 ms \\
        Constraints & 86,080 & 3,471,680 & 86,080 & 33,942,080 \\
        Proof Size & 1,055 B & 1,055 B & 1,055 B & 1,055 B \\
        Gas Cost & 208,967 & 208,967 & 208,967 & 208,967 \\
        \hline
    \end{tabular}
\end{table}

表\ref{tab:e2e_snark_phase}から、SNARKフェーズではVOLEフェーズとは異なる特性が明らかになる。
最も注目すべきは、最終的なSNARK証明のサイズが、回路のゲート数や種類に関わらず\textbf{1,055バイト}に固定されている点である。
また、オンチェーン検証のガス代も\textbf{208,967 gas}で一定であり、これはSNARKの検証が固定コストで行われることを示している。
これにより、前節で課題となったVOLEitHの巨大な証明サイズが大幅に圧縮され、オンチェーン検証の実現可能性が飛躍的に向上する。

一方で、SNARK証明の生成時間と制約数には、回路の複雑性が大きく影響している。特に、ANDゲート回路はADDゲート回路と比較して、制約数が大幅に増加し、それに伴い証明生成時間も急増している。
例えば、1000 ANDゲート回路では、制約数が33,942,080に達し、証明生成に8,003 ms（約8秒）を要している。

この関係性をより視覚的に示すため、\textbf{図1}にSNARKの制約数と証明生成時間の関係を示す。

\begin{figure}[htbp]
    \centering
    % ここにSNARKの制約数と証明生成時間の関係を示すグラフを挿入
    \caption{SNARKの制約数と証明生成時間の関係}
    \label{fig:snark_constraints_time}
\end{figure}

図\ref{fig:snark_constraints_time}は、SNARKの証明生成時間が、回路の制約数、特に乗算ゲートに起因する制約数の増加に強く相関していることを明確に示している。
これは、SNARKの証明生成における主要な計算ボトルネックが、回路の複雑性、特に乗算の多さに起因することを示唆している。

\paragraph{主な観測事項}
本章で得られたE2E測定結果から、以下の特徴が明らかになった。
\begin{itemize}
    \item ANDゲートはADDゲートよりも大幅に制約数と証明時間を増加させ、VOLEフェーズでも証明サイズを押し上げる。
    \item ADDのみの回路では制約数がほぼ一定であるのに対し、ANDゲート数に比例してSNARK制約が増える。
    \item SNARKフェーズの証明生成時間が、VOLEフェーズの生成・検証時間を大きく上回り、全体のボトルネックとなる。
    \item SNARK証明サイズおよびオンチェーン検証ガスは1,055バイトと約209k gasで一定であり、回路規模に依存しない。
    \item 総証明時間はSNARKフェーズの制約増加に強く影響されるため、複雑な回路ではクライアントデバイスでの実行が難しくなる。
\end{itemize}

\subsection{SNARK統合に関する洞察}
VOLEitHの証明をGroth16で包むと、証明サイズと検証コストは一定になる一方で、R1CS制約数が急増する。
ここでは制約数の内訳と、制約爆発の要因および緩和策を整理する。

\subsubsection{制約数の分解}
$n$ を拡張witnessの長さ（秘密入力数と乗算ゲート数の合計）とすると、全体の制約数は
\begin{align*}
16,640 \times n + 2,113,664
\end{align*}
と表せる。線形項に寄与するガジェットは表\ref{tab:linear_constraints}の通りであり、\texttt{compute\_validation\_aggregate}が支配的である。

\begin{table}[H]
    \centering
    \caption{線形に増加するガジェットの制約数}
    \label{tab:linear_constraints}
    \begin{tabular}{|l|r|}
        \hline
        ガジェット & 制約数 \\
        \hline
        $compute\_d\_delta$ & $128n$ \\
        $compute\_masked\_witness$ & $256n$ \\
        $compute\_validation\_aggregate$ & $16,512n$ \\
        \hline
        合計 & $\approx16,640n$ \\
        \hline
    \end{tabular}
\end{table}

また、回路サイズに依存しない定数項も無視できない（表\ref{tab:constant_constraints}）。乗算ゲートが増えると線形項が支配するが、ベースラインとして約200万制約が常に必要になる。

\begin{table}[H]
    \centering
    \caption{定数項として加算されるガジェット}
    \label{tab:constant_constraints}
    \begin{tabular}{|l|r|}
        \hline
        ガジェット & 制約数 \\
        \hline
        $combine$ & $\sim2,097,152$ \\
        $compute\_actual\_validation$ & $\sim16,384$ \\
        最終整合性チェック & $\sim128$ \\
        \hline
        合計 & $\sim2,113,664$ \\
        \hline
    \end{tabular}
\end{table}

\subsubsection{Field Mappingがもたらす制約爆発}
SchmivitzにおけるVOLEitHは、$\mathbb{F}_2$、$\mathbb{F}_{2^8}$、$\mathbb{F}_{2^{64}}$、$\mathbb{F}_{2^{128}}$といった2進拡大体上で計算を行う。
一方で、Groth16のR1CSはBN254の素数体上で定義されるため、各ビット列をBoolean変数列に持ち上げる必要がある。
実装では以下のように、証明内の各値を逐一Boolean配列に射影している。

\begin{verbatim}
pub fn build_circuit(
    cs: ConstraintSystemRef<Bn254Fr>,
    proof: Proof<InsecureVole>,
) -> VoleVerificationBoolean {
    let witness_commitment_booleans: Vec<Vec<Boolean<Bn254Fr>>> = proof
        .witness_commitment
        .iter()
        .map(|value| f64b_to_boolean_array(cs.clone(), value).unwrap())
        .collect();

    let witness_challenges_booleans: Vec<Vec<Boolean<Bn254Fr>>> = proof
        .witness_challenges
        .iter()
        .map(|value| f128b_to_boolean_array(cs.clone(), value).unwrap())
        .collect();
    // ...
}
\end{verbatim}

この変換により、もともと単一の体要素で表現できた計算が数百ビットのAND/XORに展開され、制約数が爆発的に増加する。

\subsubsection{ANDゲートと\texttt{witness\_challenge}}
特にANDゲートを検証する際には、\texttt{witness\_challenge}と\texttt{masked\_witness}の全ビットについてANDおよびXOR演算を行い、部分積を合成する必要がある。
実装の核心は以下の通りであり、128ビット平方の積をBooleanレベルで計算するため、ANDゲート1つあたり$2^{14}$規模の制約が追加される。

\begin{verbatim}
for (i, challenge_bit) in challenge.iter().enumerate() {
    if i >= 128 { break; }
    for (j, masked_bit) in masked_witness.iter().enumerate() {
        if j >= 128 || i + j >= 128 { continue; }
        let and_result = Boolean::and(challenge_bit, masked_bit)?;
        product[i + j] = Boolean::xor(&product[i + j], &and_result)?;
    }
}
\end{verbatim}

ADDゲートでは\texttt{witness\_challenge}が不要なため制約数は一定だが、ANDゲートが増えるほど\texttt{compute\_validation\_aggregate}が繰り返し呼ばれ、SNARKフェーズ全体のボトルネックとなる。

\subsection{技術的ボトルネックと解決策}
上記の分析から、Field MappingとGGM木再構成が制約爆発の主要因であることが分かる。
本節では、これらを緩和するための具体的な研究方向を整理する。

\subsubsection{Field Mapping最適化とLookup Table}
Mystique\cite{eprint:2021:730}は、機械学習向けに$\mathbb{F}_2$と$\mathbb{F}_p$のデータ変換を効率化するVOLEベースZKであり、Lookup Table (LUT) を導入することでさらに高速化できることが最新研究\cite{eprint:2025:507}で示されている。
表\ref{tab:mystique_lut}に示す通り、LUTを用いた場合には実行時間が61--130倍短縮し、通信量も最大2.9倍削減できる。
VOLEitHのField MappingにMystique型LUTを適用できれば、SNARKフェーズの制約数削減に直結すると期待される。

\begin{table}[H]
    \centering
    \caption{MystiqueとLUT拡張の性能比較}
    \label{tab:mystique_lut}
    \begin{tabular}{|l|l|r|r|}
        \hline
        関数 & プロトコル & 実行時間 (s) & 通信量 (MB) \\
        \hline
        指数関数 & Mystique with LUT & 8.696 & 99.020 \\
                  & Mystique & 1130.020 & 291.435 \\
        除算 & Mystique with LUT & 9.837 & 110.684 \\
             & Mystique & 617.690 & 160.428 \\
        逆平方根 & Mystique with LUT & 11.836 & 147.903 \\
                 & Mystique & 824.639 & 212.211 \\
        \hline
    \end{tabular}
\end{table}

\subsubsection{GGM木最適化とFolding}
Schmivitzでは、VOLEitH検証で最もコストの高いGGM木再構成を簡略化しているが、SNARKで完全に検証する場合はこの部分が制約増大を引き起こす。
著者らはGGM木を効率化する手法\cite{eprint:2024:490}に加え、FAESTを改良したFAESTERを提案しており、署名サイズと計算量をともに改善している（表\ref{tab:faester}）。
本研究で検討したFoldingスキームとこれらの最適化を組み合わせれば、将来的にGGM木再構成部の制約数を抑制できる。

\begin{table}[H]
    \centering
    \caption{FAESTとFAESTERの比較（セキュリティ128ビット）}
    \label{tab:faester}
    \begin{tabular}{|l|l|r|r|r|}
        \hline
        スキーム & バージョン & 署名サイズ (B) & 署名時間 (ms) & 検証時間 (ms) \\
        \hline
        FAEST & Slow & 50,063 & 4.3813 & 4.1023 \\
              & Fast & 63,363 & 0.4043 & 0.3953 \\
        FAESTER & Slow & 45,943 & 3.2823 & 4.4673 \\
                 & Fast & 60,523 & 0.4333 & 0.6103 \\
        \hline
    \end{tabular}
\end{table}

\subsection{総合考察とトレードオフ分析}
これまでの分析結果を統合し、VOLEitHとSNARKを組み合わせたアーキテクチャ全体の有効性とトレードオフについて考察する。

本研究で採用したアーキテクチャは、\textbf{図2}に示すように、証明者側（Prover）で2段階のプロセスを経て、検証者側（Verifier）であるブロックチェーン上で効率的な検証を実現するものである。

\begin{figure}[htbp]
    \centering
    % ここにVOLEitH + SNARKによる証明圧縮プロセスの概念図を挿入
    % 例: [Prover: 回路] -> [VOLEitH証明 (数MB)] -> [SNARK証明 (1KB)] -> [Verifier (オンチェーン)]
    \caption{VOLEitH + SNARKによる証明圧縮プロセスの概念図}
    \label{fig:proof_compression_flow}
\end{figure}

図\ref{fig:proof_compression_flow}が示す通り、本アーキテクチャは、VOLEitHが生成する巨大な証明（数MBオーダー）を、SNARKを用いてオンチェーン検証に適したコンパクトな証明（1KBオーダー）に圧縮する点に核心がある。
このアプローチにより、以下の2つの大きな利点を両立することが可能となる。

\begin{enumerate}
    \item \textbf{高速な証明者計算}: VOLEitHは、Circomのような従来のR1CSベースのシステムと比較して、証明者の計算が非常に高速である（表\ref{tab:sha256_comparison}参照）。
    これにより、計算能力が限られるクライアントデバイス（例: Webブラウザ、スマートフォン）でも、複雑な計算の証明を現実的な時間で生成できる可能性が広がる。
    \item \textbf{低コストなオンチェーン検証}: SNARK化された証明は、サイズが小さく、検証コストが回路の複雑さによらず一定であるため、ブロックチェーン上での検証コスト（ガス代）を大幅に削減し、予測可能なものにできる（表\ref{tab:e2e_snark_phase}参照）。
\end{enumerate}

一方で、このアーキテクチャには考慮すべきトレードオフも存在する。最大のトレードオフは、証明者側の計算負荷である。
証明者は、高速なVOLEitH証明生成に加えて、SNARK証明を生成するための追加の計算コストを負担する必要がある。
特に、回路が多くの乗算（ANDゲート）を含む場合、SNARKの制約数が急増し、SNARK証明の生成時間が全体のボトルネックとなる（図\ref{fig:snark_constraints_time}参照）。

したがって、本アーキテクチャは、以下のような特性を持つユースケースにおいて特に有効であると考えられる。
\begin{itemize}
    \item \textbf{クライアントサイドでの証明生成}: ユーザー自身のデバイスで証明を生成し、サーバーやブロックチェーンに送信するアプリケーション。
    例えば、プライバシーを保護した上での本人確認（分散型ID）、プライベートな状態を持つゲーム、機密データを用いた計算の検証などが挙げられる。
    \item \textbf{オンチェーンコストの最小化が重要}: ブロックチェーンのスケーラビリティが重視され、トランザクションコストを可能な限り抑えたいアプリケーション。
\end{itemize}

結論として、VOLEitHとSNARKを組み合わせたハイブリッドアプローチは、「証明者の高速性」と「検証者の低コスト」という、一見すると相反する要求を両立させるための有望なアーキテクチャである。
その性能は回路の特性、特に乗算の数に大きく依存するため、アプリケーションを設計する際には、このトレードオフを十分に理解することが重要となる。
