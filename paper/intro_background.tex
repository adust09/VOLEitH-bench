\section{序論 (Introduction)}
\subsection{ゼロ知識証明の進化とオンチェーン検証の課題}
ゼロ知識証明（Zero-Knowledge Proof, ZKP）は、ある計算が正しく実行されたことを、その計算に関する入力情報（witness）を一切明らかにすることなく検証者に証明するための暗号学的プロトコルである。この「ゼロ知識」という性質は、プライバシー保護が強く求められる現代のデジタル社会において極めて重要であり、認証、電子投票、そして特にブロックチェーン技術の分野でその応用が期待されている。

ブロックチェーン、特にスマートコントラクトプラットフォームにおいては、計算の正当性をトラストレストランザクションとしてオンチェーンで検証する能力が、スケーラビリティとプライバシーの両方を向上させる鍵となる。例えば、計算量の多い処理をオフチェーンで実行し、その結果の正当性のみをZKPを用いてオンチェーンで検証する「ZKロールアップ」は、Ethereumのスケーラビリティ問題を解決する主要なアプローチとして注目を集めている。しかし、ZKPをオンチェーンで検証する際には、証明サイズ、検証計算量、そしてそれに伴うガス代という、ブロックチェーン特有の厳しい制約が大きな課題となる。

\subsection{VOLEベースZKPとVOLE-in-the-Head}
この課題に対し、証明者（Prover）の計算効率を大幅に向上させる新しいZKPの系統として、VOLE（Vector Oblivious Linear Evaluation）ベースのプロトコルが登場した。これらのプロトコルは、従来のSNARKsで主流であったR1CS（Rank-1 Constraint System）とは異なるアプローチを取り、特に証明者の計算負荷を軽減することに成功している。

その中でもVOLE-in-the-Head (VOLEitH) は、VOLEベースの対話型プロトコルにFiat-Shamir変換を適用することで、誰でも検証可能な公開証明（publicly verifiable proof）を生成可能にした画期的な手法である。これにより、証明者側の高い計算効率という利点を維持しつつ、オンチェーン検証への道が拓かれた。

\subsection{研究の目的と貢献}
VOLEitHは理論的には有望であるものの、その実用性、特にオンチェーン検証における具体的な性能やコストについては、まだ十分に明らかにされていない。本研究の目的は、VOLEitHをSNARKと組み合わせたハイブリッドアーキテクチャを構築し、そのエンドツーエンドの性能を定量的に評価することにある。

具体的には、以下の項目を詳細に測定・分析する。
\begin{itemize}
    \item 証明生成と検証にかかる時間
    \item 各フェーズで生成される証明のサイズ
    \item 証明者と検証者の計算負荷（CPU、メモリ）
    \item 最終的なオンチェーン検証にかかるガス代
\end{itemize}
本研究は、VOLEitHのオンチェーン応用における実現可能性と技術的なトレードオフを明らかにすることで、将来的なZKPシステムの設計と最適化、そしてブロックチェーンアプリケーションにおけるプライバシーとスケーラビリティの向上に貢献することを目指す。

\subsection{論文の構成}
本論文は以下のように構成される。第2章では、本研究の基礎となるZKP、VOLE、VOLEitH、SNARKsの技術的背景を解説する。第3章では、性能評価に用いたベンチマークの設計と環境について詳述する。第4章では、ベンチマーク結果を提示し、詳細な分析と考察を行う。第5章では、関連研究との比較を行う。最後に第6章で、本研究の結論と今後の展望を述べる。

\section{背景 (Background)}
本章では、我々の研究の基礎となる暗号学的概念とプロトコルについて解説する。

\subsection{ゼロ知識証明の基礎}
ゼロ知識証明（ZKP）は、証明者（Prover）が検証者（Verifier）に対し、ある表明が真であることを、その表明の真実性を担保する情報（witness）を一切明かすことなく納得させるためのプロトコルである。ZKPは以下の3つの性質を満たす必要がある。
\begin{enumerate}
    \item \textbf{完全性 (Completeness)}: 証明者の表明が真であるならば、正直な証明者は正直な検証者を必ず納得させることができる。
    \item \textbf{健全性 (Soundness)}: 証明者の表明が偽であるならば、不正な証明者が正直な検証者を騙して納得させられる確率は、無視できるほど小さい。
    \item \textbf{ゼロ知識性 (Zero-Knowledge)}: 検証者は、証明の正当性以外には、証明者の持つ秘密情報について何も知ることができない。
\end{enumerate}
ZKPは、証明者と検証者の間で複数回のやり取りを必要とする「対話型証明システム」と、証明者が一度証明を公開すれば誰でも検証できる「非対話型証明システム（NIZK）」に大別される。オンチェーン検証のように、不特定多数の検証者が非同期に検証を行う環境では、NIZKが不可欠となる。

\subsection{VOLEと関連プロトコル}
VOLE（Vector Oblivious Linear Evaluation）は、二者間（SenderとReceiver）のセキュアな計算プロトコルであり、近年のZKPシステムの効率化に大きく貢献している。基本的なVOLEプロトコルでは、Senderが持つアフィン変換 \texttt{f(x) = ax + b} と、Receiverが持つベクトル \texttt{u} に対し、Receiverが \texttt{v = au + b} を計算する。この過程で、Senderは \texttt{u} について、Receiverは \texttt{a, b} について何も知ることができない。

VOLEベースのプロトコルの多くは、LPN（Learning Parity with Noise）仮定の困難性に基づいている。LPN仮定とは、ランダムな線形方程式系にノイズが加わったものから、元の線形関係を復元することが計算量的に困難であるという仮定であり、これにより量子コンピュータに対しても耐性を持つ（ポスト量子暗号）と考えられている。

VOLEをZKPに応用するために、SPVOLE（Single-Point VOLE）やZP-VOLE（Zero-Point VOLE）といった派生プロトコルが考案された。これらは、特定の点でのみ値が非ゼロになるようなベクトルを効率的に扱うためのプロトコルであり、算術回路の各ゲートにおける制約を表現するのに適している。

\subsection{VOLE-in-the-Head (VOLEitH)}
VOLE-in-the-Head (VOLEitH) は、VOLEベースのプロトコルをZKPに昇華させた手法である。その基本的なアイデアは、証明したい算術回路のワイヤ値をProverがコミットし、Verifierがランダムな線形結合をチェックすることで、回路全体の計算が正しく行われたかを検証するというものである。

本研究で利用する\texttt{soft\_spoken}ライブラリは、VOLEitHの具体的な実装の一つである。\texttt{soft\_spoken}では、SPVOLEとZP-VOLEを巧みに組み合わせることで、効率的な証明生成を実現している。プロトコルの流れは以下のようになる。
\begin{enumerate}
    \item \textbf{コミットメント}: Proverは、算術回路の各ワイヤの値を表すベクトルにコミットする。
    \item \textbf{チャレンジ}: Verifierは、ランダムなチャレンジ（乱数）をProverに送信する。
    \item \textbf{レスポンス}: Proverは、チャレンジに基づき、コミットしたベクトル間の線形関係が成立することを示すための情報を計算し、Verifierに返信する。
    \item \textbf{検証}: Verifierは、Proverからのレスポンスと自身が持つ情報を用いて、線形関係が成立するかをチェックする。もし成立すれば、Proverが回路を正しく計算したと確信する。
\end{enumerate}
この対話型のプロトコルを非対話的にするため、Fiat-Shamir変換が用いられる。これは、Verifierが生成するランダムなチャレンジを、プロトコルのここまでの情報（コミットメント等）をハッシュ関数に入力することで自己生成するテクニックである。これにより、ProverはVerifierとの対話なしに証明を一方的に生成でき、生成された証明は誰でも検証可能なNIZKとなる。

\subsection{SNARKsとオンチェーン検証}
VOLEitHによって生成された証明は、証明者の計算効率は高いものの、証明サイズが非常に大きいという問題がある（\ref{sec:results_analysis} 4.1節で詳述）。このままではオンチェーン検証は現実的ではないため、証明をさらに圧縮する技術が必要となる。

ここで登場するのがSNARK（Succinct Non-interactive Argument of Knowledge）である。SNARK、特に現在主流のGroth16などは、証明サイズを数百バイト程度まで劇的に圧縮することができる。これは、計算の正当性の問題を、特定の性質を持つ多項式の存在問題に変換し、その多項式に対するコミットメントをペアリングという暗号学的道具立てを用いて効率的に検証することで実現される。

SNARKの検証は、Ethereum Virtual Machine (EVM) 上でスマートコントラクトとして実装できる。検証コントラクトは、いくつかのペアリング演算と比較を行うだけで証明を検証できるため、計算量が比較的小さく、ガス代を低く抑えることが可能である。これにより、VOLEitHの巨大な証明をSNARKで圧縮し、そのコンパクトなSNARK証明をオンチェーンで検証するという、本研究のハイブリッドアーキテクチャが実現される。
\section{実現可能性分析と主要な知見}
Milestone 1と2では、VOLEitHの証明をオンチェーンで扱うために複数の手法を検討し、最終的にGroth16によるSNARK Wrappingを実装・評価した。本節では、その意思決定過程と主要な洞察を整理する。

\subsection{SNARK Wrapping (Groth16)}
最も直接的なアプローチは、VOLEitHの検証ロジック全体をGroth16で包む方法である。この手法により、回路規模やゲート種別に依らず証明サイズを\textbf{1,055バイト}、オンチェーン検証ガスを\textbf{208,967 gas}に固定できた。一方で、制約数は
\begin{align*}
16,640 \times n + 2,113,664
\end{align*}
と線形に増加し、特に非線形ゲートを多く含む回路では証明生成時間が急増する。実装は以下のコンポーネントで構成される。
\begin{itemize}
    \item \texttt{schmivitz-snark}: VOLEitH検証ロジックをarkworksベースのGroth16で証明するためのラッパー
    \item \texttt{VOLEitH-bench}: Groth16圧縮後の証明をEVMで検証し、エンドツーエンド性能を測定するベンチマーク
\end{itemize}
SHA-256のようにANDゲートが2万個を超える回路では、この制約爆発によりSNARKフェーズの実装を断念せざるを得なかった。

\subsection{Foldingアプローチの検討}
Milestone 1では、VOLEitHの検証ロジックが階層的な構造を持つことから、NIVCを用いたFoldingスキームへの写像も検討した。特にGGM木の再構成部分はPRGとハッシュ関数のみから構成されるため、Foldingを用いれば証明サイズをより小さく保てる可能性がある。しかし、現状の\texttt{sonobe}実装はNIVCをサポートしておらず、SchmivitzのVOLE実装もGGM木の完全な再構成を含んでいないため、本プロジェクトでは採用を見送った。この方向性は今後の改良候補として残している。

\subsection{Blobを用いた格納案}
当初はEIP-4844のBlobにVOLEitH証明を格納する案も検討したが、現状のEVMはオンチェーンからBlobデータへアクセスできない。そのため、証明サイズが縮小されない限りオンチェーン検証に利用できないと判断し、この案も採用しなかった。
