\section{背景 (Background)}
本章では、我々の研究の基礎となる暗号学的概念とプロトコルについて解説する。

\subsection{ゼロ知識証明の基礎}
ゼロ知識証明（ZKP）は、証明者（Prover）が検証者（Verifier）に対し、ある表明が真であることを、その表明の真実性を担保する情報（witness）を一切明かすことなく納得させるためのプロトコルである。ZKPは以下の3つの性質を満たす必要がある。
\begin{enumerate}
    \item \textbf{完全性 (Completeness)}: 証明者の表明が真であるならば、正直な証明者は正直な検証者を必ず納得させることができる。
    \item \textbf{健全性 (Soundness)}: 証明者の表明が偽であるならば、不正な証明者が正直な検証者を騙して納得させられる確率は、無視できるほど小さい。
    \item \textbf{ゼロ知識性 (Zero-Knowledge)}: 検証者は、証明の正当性以外には、証明者の持つ秘密情報について何も知ることができない。
\end{enumerate}
ZKPは、証明者と検証者の間で複数回のやり取りを必要とする「対話型証明システム」と、証明者が一度証明を公開すれば誰でも検証できる「非対話型証明システム（NIZK）」に大別される。オンチェーン検証のように、不特定多数の検証者が非同期に検証を行う環境では、NIZKが不可欠となる。

\subsection{VOLEと関連プロトコル}
VOLE（Vector Oblivious Linear Evaluation）は、二者間（SenderとReceiver）のセキュアな計算プロトコルであり、近年のZKPシステムの効率化に大きく貢献している。
基本的なVOLEプロトコルでは、Senderが持つアフィン変換 \texttt{f(x) = ax + b} と、Receiverが持つベクトル \texttt{u} に対し、Receiverが \texttt{v = au + b} を計算する。
この過程で、Senderは \texttt{u} について、Receiverは \texttt{a, b} について何も知ることができない。

VOLEベースのプロトコルの多くは、LPN（Learning Parity with Noise）仮定の困難性に基づいている。
LPN仮定とは、ランダムな線形方程式系にノイズが加わったものから、元の線形関係を復元することが計算量的に困難であるという仮定であり、これにより量子コンピュータに対しても耐性を持つ（ポスト量子暗号）と考えられている。

VOLEをZKPに応用するために、SPVOLE（Single-Point VOLE）やZP-VOLE（Zero-Point VOLE）といった派生プロトコルが考案された。
これらは、特定の点でのみ値が非ゼロになるようなベクトルを効率的に扱うためのプロトコルであり、算術回路の各ゲートにおける制約を表現するのに適している。

\subsection{VOLE-in-the-Head (VOLEitH)}
VOLE-in-the-Head (VOLEitH) は、VOLEベースのプロトコルをZKPに昇華させた手法である。
その基本的なアイデアは、証明したい算術回路のワイヤ値をProverがコミットし、Verifierがランダムな線形結合をチェックすることで、回路全体の計算が正しく行われたかを検証するというものである。

本研究で利用する\texttt{soft\_spoken}ライブラリは、VOLEitHの具体的な実装の一つである。\texttt{soft\_spoken}では、SPVOLEとZP-VOLEを巧みに組み合わせることで、効率的な証明生成を実現している。プロトコルの流れは以下のようになる。
\begin{enumerate}
    \item \textbf{コミットメント}: Proverは、算術回路の各ワイヤの値を表すベクトルにコミットする。
    \item \textbf{チャレンジ}: Verifierは、ランダムなチャレンジ（乱数）をProverに送信する。
    \item \textbf{レスポンス}: Proverは、チャレンジに基づき、コミットしたベクトル間の線形関係が成立することを示すための情報を計算し、Verifierに返信する。
    \item \textbf{検証}: Verifierは、Proverからのレスポンスと自身が持つ情報を用いて、線形関係が成立するかをチェックする。もし成立すれば、Proverが回路を正しく計算したと確信する。
\end{enumerate}
この対話型のプロトコルを非対話的にするため、Fiat-Shamir変換が用いられる。これは、Verifierが生成するランダムなチャレンジを、プロトコルのここまでの情報（コミットメント等）をハッシュ関数に入力することで自己生成するテクニックである。
これにより、ProverはVerifierとの対話なしに証明を一方的に生成でき、生成された証明は誰でも検証可能なNIZKとなる。

\subsection{SNARKsとオンチェーン検証}
VOLEitHによって生成された証明は、証明者の計算効率は高いものの、証明サイズが非常に大きいという問題がある（\ref{sec:results_analysis} 4.1節で詳述）。このままではオンチェーン検証は現実的ではないため、証明をさらに圧縮する技術が必要となる。

ここで登場するのがSNARK（Succinct Non-interactive Argument of Knowledge）である。SNARK、特に現在主流のGroth16などは、証明サイズを数百バイト程度まで劇的に圧縮することができる。
これは、計算の正当性の問題を、特定の性質を持つ多項式の存在問題に変換し、その多項式に対するコミットメントをペアリングという暗号学的道具立てを用いて効率的に検証することで実現される。

SNARKの検証は、Ethereum Virtual Machine (EVM) 上でスマートコントラクトとして実装できる。検証コントラクトは、いくつかのペアリング演算と比較を行うだけで証明を検証できるため、計算量が比較的小さく、ガス代を低く抑えることが可能である。
これにより、VOLEitHの巨大な証明をSNARKで圧縮し、そのコンパクトなSNARK証明をオンチェーンで検証するという、本研究のハイブリッドアーキテクチャが実現される。

\subsection{信頼モデルと安全性仮定}
TODO: CRSセットアップ、透明性、LPN系と楕円曲線系の安全性仮定を比較し、VOLEitHとSNARKの組み合わせが依存する前提を列挙する。

\subsection{オンチェーン検証に必要な運用前提}
TODO: コントラクトデプロイ、鍵管理、Blobやカリブレーションデータの配信方法など、実運用で想定されるオフチェーン連携要件を整理する。
