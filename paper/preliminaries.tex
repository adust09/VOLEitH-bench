\section{前提知識と関連研究}
本章では、後続のベンチマークと考察を理解するために必要な暗号学的前提を簡潔に整理する。

\subsection{Vector Oblivious Linear Evaluation (VOLE)}
Vector Oblivious Linear Evaluation（VOLE）は、二者間で線形関係を秘匿したまま、ある種の相関を生成するための暗号学的プリミティブである。
$k$をセキュリティパラメータ、$\mathbb{F}_{2^k}$を要素数$2^k$の有限体とする。
証明者（Prover）はベクトル$\mathbf{u} \in \mathbb{F}_2^\ell$と$\mathbf{v} \in \mathbb{F}_{2^k}^\ell$を、検証者（Verifier）はグローバルキー$\Delta \in \mathbb{F}_{2^k}$を入力とする。
プロトコル終了後、検証者は$\mathbf{q} \in \mathbb{F}_{2^k}^\ell$を得て、証明者は$(\mathbf{u}, \mathbf{v})$を、検証者は$(\Delta, \mathbf{q})$を保持する。これらの値は以下のVOLE相関式を満たす。
\begin{equation}
    q_i = u_i \cdot \Delta + v_i \quad (i=0, \dots, \ell-1)
\end{equation}
この相関は、$u_i$に対する線形準同型コミットメントとして機能する。
\begin{description}
    \item[秘匿性 (Hiding)] 検証者は$q_i$から$u_i$の情報を得られない。これは、証明者が知るランダムな値$v_i$が$u_i$をマスクするためである。
    \item[拘束性 (Binding)] 証明者は、コミットした$u_i$とは異なる値$u'_i$を開示することができない。これを行うには$\Delta$を推測する必要があるが、その成功確率は$2^{-k}$であり、計算論的に無視できる。
\end{description}

\subsection{VOLE-based ZK}
VOLEの持つ線形性（加法準同型性）を利用することで、効率的なゼロ知識証明プロトコル（VOLE-based ZK）を構築できる。
このパラダイムに基づく代表的なプロトコルとしてQuickSilverがある。
VOLEベースの証明は、事前にVOLE相関をバッチ生成（pre-processing）しておき、オンラインフェーズでは軽い計算のみで証明を生成できるため、証明者・検証者ともに非常に高速である。

しかし、従来のVOLE-ZKプロトコルは、その健全性（Soundness）を保証するために、検証者がグローバルキー$\Delta$の値を秘密に保つ必要があった。
このため、証明を検証できるのが特定の検証者に限定される\textbf{指定検証者証明（Designated Verifier Proof）}となり、第三者が検証できる\textbf{公開検証可能性（Public Verifiability）}を持たないという課題があった。

\subsection{VOLE-in-the-Head}
VOLE-in-the-Head（VOLEitH）は、上記のような指定検証者型のVOLE-ZKプロトコルを、非対話かつ公開検証可能なゼロ知識証明（NIZK）に変換するためのコンパイラである。
VOLEitHは、MPC-in-the-HeadパラダイムとVOLEを組み合わせたもので、証明の健全性を単一の証明者の計算能力に帰着させる。

VOLEitHの核となるアイデアは、検証者が秘密情報（$\Delta$）を持つ代わりに、証明者自身がコミットし、後からFiat-Shamir変換によって$\Delta$を導出する点にある。
\begin{enumerate}
    \item \textbf{コミットメント}: 証明者は、VOLE相関の元となるシード（seed）のベクトルにコミットする。このコミットメントには、GGMツリー（擬似乱数生成器を再帰的に適用する構成）に基づく\textbf{All-but-One ベクトルコミットメント}が用いられ、単一のハッシュ値で多数のシードをコミットできる。
    \item \textbf{チャレンジ生成}: 証明の主要部分が生成された後、Fiat-Shamir変換を用いて、証明全体のトランスクリプトからチャレンジとしてグローバルキー$\Delta$が導出される。$\Delta$が事前にわかると拘束性が破られるため、この「遅延」が重要である。
    \item \textbf{開示と検証}: $\Delta$が定まった後、証明者はコミットメントを開示する。All-but-Oneコミットメントの性質により、$N$個のシードのうち$N-1$個を$O(\log N)$の通信量で開示できる。開示されなかった1つのシードに対応する部分が、VOLEにおける$\Delta$の役割を果たす。
\end{enumerate}
検証者は、開示された情報と自身で計算した$\Delta$を用いてVOLE相関式を検証する。これにより、検証者が事前に秘密を共有することなく、誰でも証明を検証できる公開検証可能性が実現される。

\subsection{Groth16}
Groth16は、現在最も広く利用されているzk-SNARKsの一つであり、特にその証明サイズの小ささと検証の速さで知られている。
ブロックチェーンのように検証コストが重視される環境において、特に強力な選択肢となる。

Groth16プロトコルは主に3つのアルゴリズムから構成される：
\begin{description}
    \item[Setup] 回路（通常はR1CS形式）から、証明鍵（Proving Key, pk）と検証鍵（Verification Key, vk）を生成する。
    このプロセスは回路ごとに一度だけ実行する必要があり、信頼できる第三者または複数当事者によるセレモニー（Trusted Setup）を必要とする。
    このセットアップで用いられた乱数（"toxic waste"）が漏洩すると、不正な証明が生成可能になるという課題がある。
    \item[Prove] 証明者は、証明鍵、公開入力（witness）、および秘密入力を用いて、証明（proof, $\pi$）を生成する。
    \item[Verify] 検証者は、検証鍵、公開入力、および証明$\pi$を受け取り、その正当性を検証する。
\end{description}

Groth16の証明は、特定の楕円曲線（例: BN254）上の3つの群要素（$\mathbb{G}_1$の元2つ、$\mathbb{G}_2$の元1つ）で構成され、回路の規模に関わらず常に一定のサイズである。
検証は、数回のペアリング演算によって行われ、極めて高速に完了する。
この効率性の代償として、回路ごとに異なるTrusted Setupが必要であり、汎用性（universality）に欠けるというトレードオフが存在する。


\subsection{オンチェーン検証}
オンチェーン検証とは、ブロックチェーン上で暗号学的証明の正当性を検証するプロセスを指す。本稿では特に、Ethereum仮想マシン（EVM）上でzk-SNARKの証明を検証するケースを扱う。

Ethereumは、\textbf{スマートコントラクト}と呼ばれるプログラムを実行できる分散型プラットフォームである。
スマートコントラクトは一度デプロイされると、そのロジックは誰でも呼び出すことができ、実行結果はブロックチェーンに記録され、改ざんが困難となる。
しかし、スマートコントラクトの実行には\textbf{ガス}と呼ばれる手数料が必要であり、計算が複雑であるほど高額になる。
このため、オンチェーンでの利用には、検証コストが極めて低い証明システムが不可欠となる。

この文脈でGroth16が広く採用されるのは、その\textbf{証明サイズが小さい}（回路の規模に関わらず一定かつBN254曲線で約1KBと非常に小さい）点と、\textbf{検証が高速}である点にある。
ブロックチェーンに送信するデータ（calldata）や計算はガス代に直結するため、これらの特性はオンチェーン検証の経済性を大きく左右する。

Ethereum上でGroth16の証明を検証するには、Solidityで記述された検証コントラクトが用いられる。
この検証ロジックは、Ethereumに予め組み込まれた\textbf{プリコンパイル済みコントラクト}を利用することで、効率的に実行される。
具体的には、アドレス`0x08`に配置された`ecPairing`というプリコンパイル済みコントラクトが、BN254曲線におけるペアリング演算をネイティブ実装に近い速度で提供する。

検証のプロセスは以下の通りである。
まず、開発者は証明対象の回路に対応する検証鍵（Verification Key, vk）を含むスマートコントラクト（例: Verifier.sol）をEthereumにデプロイする。
次に、証明を検証したいユーザーは、証明（proof, $\pi$）と公開入力（public inputs）をトランザクションとして検証コントラクトに送信する。
検証コントラクトは、受け取った証明と公開入力、そしてコントラクト内に保管された検証鍵を用いてGroth16の検証方程式を評価する。
この際、高コストなペアリング演算は`ecPairing`プリコンパイル済みコントラクトを呼び出して実行し、方程式が成立すれば証明は正当であると判定される。
この結果に基づき、コントラクトは後続の処理（状態の更新や別のコントラクト呼び出しなど）を行う。

このようなオンチェーンZKアプリケーション開発において、\textbf{Circom}は算術回路を記述するためのドメイン固有言語（DSL）であり、そのツールチェーン（`snarkjs`を含む）は、回路記述の容易さに加え、コンパイルされた回路からGroth16の検証鍵を抽出し、それに基づいた\textbf{Solidity製の検証コントラクト（`Verifier.sol`）を自動生成する機能}を持つ。
これにより、開発者は複雑なペアリング演算のロジックを自ら実装することなく、効率的にオンチェーン検証用のスマートコントラクトを準備することが可能となる。
