\section{前提知識と関連研究}
本章では、後続のベンチマークと考察を理解するために必要な暗号学的前提を簡潔に整理する。
\subsection{Vector Oblivious Linear Evaluation (VOLE)}
Vector Oblivious Linear Evaluation（VOLE）は、Oblivious Transfer (OT) の算術形式と見なされる暗号学的プリミティブであり、証明者（Prover, P）と検証者（Verifier, V）の間で、秘密裡に線形代数的な相関関係を確立する二者間プロトコルである。

$k$をセキュリティパラメータ、$\mathbb{F}_{2^k}$を要素数$2^k$の有限体とする。プロトコル完了後、Pは秘密のベクトル $\mathbf{u} \in \mathbb{F}_2^\ell$ とランダムなVOLEタグ $\mathbf{v} \in \mathbb{F}_{2^k}^\ell$ を知り、Vはグローバルキー $\Delta \in \mathbb{F}_{2^k}$ とVOLEキー $\mathbf{q} \in \mathbb{F}_{2^k}^\ell$ を知る。これらの値は、以下のVOLE相関式を満たす。
\begin{equation}
    q_i = u_i \cdot \Delta + v_i \quad (i=0, \dots, \ell-1)
\end{equation}
この相関は、Pが持つランダムビット $u_i$ に対する\textbf{線形準同型コミットメントスキーム}として機能する。このコミットメントは以下の性質を持つ。
\begin{description}
    \item[秘匿性 (Hiding)] Vは、$q_i$と$\Delta$から$u_i$の情報を得られない。これは、Pが知るランダムな値$v_i$が$u_i$の値をマスクするためである。
    \item[拘束性 (Binding)] Pは、Vの持つ秘密$\Delta$を知らない限り、一度コミットした$u_i$を不正な値に開示することができない。その成功確率は計算論的に無視できるほど小さい。
\end{description}
VOLEの最も強力な特性は、この線形準同型性にある。同じグローバルキー$\Delta$を持つ複数のVOLE相関 $(u_i, v_i, q_i)$ と公開定数 $c, c_1, \dots, c_n \in \mathbb{F}_{2^k}$ が与えられたとき、PとVは新しい値 $u' = c + \sum_{i=1}^{n} c_i u_i$ に対するVOLE相関 $(u', v', q')$ を、追加の通信なしにローカルで計算できる。
\begin{description}
    \item[証明者の計算] Pは新しいVOLEタグ$v'$を以下のように計算する。
    \begin{equation}
        v' = \sum_{i=1}^{n} c_i v_i
    \end{equation}
    \item[検証者の計算] Vは新しいVOLEキー$q'$を以下のように計算する。
    \begin{equation}
        q' = c \cdot \Delta + \sum_{i=1}^{n} c_i q_i
    \end{equation}
\end{description}
このように、加法やスカラー乗法といった線形演算は、追加の通信を必要としないため、実質的にコストゼロで実行できる。一方で、乗算のような非線形演算はローカル計算だけでは処理できず、追加の通信を伴う特別な検定プロトコルが必要となる。これがVOLEベースのゼロ知識証明における主要なコスト源であり、次節以降で詳述する。

\subsection{VOLE-based ZKと乗算検定}
VOLEの持つ線形性（加法準同型性）を利用することで、効率的なゼロ知識証明プロトコル（VOLE-based ZK）を構築できる。このパラダイムは、QuickSilver\cite{quicksilver}などのプロトコルで採用されている。VOLEベースの証明は、証明者・検証者ともに非常に高速であるが、その主要な計算コストは乗算のような非線形演算の検証に集約される。

乗算ゲート、例えば $w_\gamma = w_\alpha \cdot w_\beta$ の検証は、特別な\textbf{乗算検定プロトコル}を必要とする。このプロトコルは、証明者と検証者が保持するVOLE相関が、実際の乗算関係を正しく反映しているかを、検証者の秘密キー$\Delta$を利用して確認するものである。
\begin{description}
    \item[証明者の役割] 証明者は、乗算ゲートに関わる自身の秘密値（$u_\alpha, v_\alpha, u_\beta, v_\beta$など）に基づいて、中間値である$a_0$と$a_1$を計算し、検証者に送信する。
    \item[検証者の役割] 検証者は、自身が持つVOLEキー（$q_\alpha, q_\beta, q_\gamma$）から特定の値$b$を計算する。その後、証明者から受け取った$a_0, a_1$と、自身の秘密キー$\Delta$を用いて、以下の線形な等式が成立するかを検証する。
    \begin{equation}
        b \stackrel{?}{=} a_0 + a_1 \cdot \Delta
    \end{equation}
    このチェックが成功すれば、証明者が正直に計算を行ったことが高い確率で保証される。もし証明者が不正を働いていた場合、この等式を成立させるには$\Delta$の値を推測する必要があり、その成功確率は計算論的に無視できるほど小さい。
\end{description}

しかし、この仕組みは、検証者がグローバルキー$\Delta$の値を秘密に保つことを前提としている。このため、証明を検証できるのが特定の検証者に限定される\textbf{指定検証者証明（Designated Verifier Proof）}となり、第三者が検証できる\textbf{公開検証可能性（Public Verifiability）}を持たないという課題があった。

\subsection{VOLE-in-the-Head}
前節で述べた指定検証者問題を解決し、公開検証可能性を実現するのがVOLE-in-the-Head (VOLEitH) と呼ばれるコンパイラである。これはFAEST \cite{faest} やzkPassなどのシステムで採用されており、本研究で利用するSchmivitzライブラリ\cite{schmivitz}もこのパラダイムに基づいている。VOLEitHは、SoftSpokenOT \cite{softspokenot} のような効率的なVOLE相関生成プロトコルを、MPC-in-the-Head \cite{mpc-in-the-head} の手法と組み合わせることで、非対話かつ公開検証可能な証明を構築する。

その核心は、検証者が秘密のグローバルキー$\Delta$を持つ代わりに、証明者自身がプロトコルの中で$\Delta$の元となる情報にコミットし、後からFiat-Shamir変換によってチャレンジとして$\Delta$を導出する点にある。これにより、検証者は事前の秘密情報を必要とせず、誰でも証明を検証できるようになる。

SoftSpokenOTをベースとしたVOLEitHプロトコルは、主に以下のステップで構成される。
\begin{description}
    \item[ステップ1: シード生成とコミットメント]
    証明者は、$N$個のランダムなシード $sd_0, \ldots, sd_{N-1}$ を生成する。次に、これらのシードに対してAll-but-Oneベクトルコミットメント（VC）スキームを用いてコミットする。このVCは、GGMツリー\cite{ggm}構成を用いて、単一のハッシュ値 $h_{com}$ だけで全シードを拘束する。証明者はこの $h_{com}$ を検証者に送る（あるいは証明トランスクリプトに含める）。

    \item[ステップ2: VOLE値の計算]
    証明者は、コミットした各シード $sd_i$ を擬似乱数生成器（PRG）で展開して文字列 $r_i$ を得る。そして、これらの文字列を用いて自身の秘密VOLE値である $\mathbf{u}$ と $\mathbf{v}$ を有限体 $\mathbb{F}_{2^k}$ 上で計算する。
    \begin{align}
        \mathbf{u} &= \sum_{i=0}^{N-1} r_i \\
        \mathbf{v} &= \sum_{i=0}^{N-1} i \cdot r_i
    \end{align}
    
    \item[ステップ3: チャレンジの決定と開示]
    証明の主要部分が構成された後、Fiat-Shamir変換を用いて、証明全体のトランスクリプトからチャレンジとしてグローバルキー $\Delta \in \{0, \ldots, N-1\}$ が導出される。証明者は、この $\Delta$ に対応するシード $sd_\Delta$ \textit{以外}の、すべての$N-1$個のシードを開示するための証明情報 $pdecom$ を生成し、証明に含める。GGMツリーの性質により、$pdecom$ のサイズは $O(\log N)$ と非常に小さい。

    \item[ステップ4: 検証とVOLEキーの再構成]
    検証者は、証明を受け取ると、まずFiat-Shamir変換で証明者と同じ $\Delta$ を導出する。次に、証明に含まれる $h_{com}$ と $pdecom$ を用いて、開示された $N-1$ 個のシードが正規のものであるかを検証する。最後に、検証者はこれらのシードと自身の $\Delta$ を用いて、VOLEキー $\mathbf{q}$ を再構成する。この $\mathbf{q}$ が、証明者の持つ $(\mathbf{u}, \mathbf{v})$ との間で $q_i = u_i \cdot \Delta + v_i$ というVOLE相関を正しく満たしているかを、後続の乗算検定などでチェックすることで、証明全体の正当性が検証される。
\end{description}

\subsection{Groth16}
まず、Groth16を理解するために、zk-SNARKs（zero-knowledge Succinct Non-interactive ARguments of Knowledge）について説明する。
zk-SNARKsは、以下の性質を持つ暗号学的証明システムである。
\begin{itemize}
    \item \textbf{ゼロ知識 (Zero-Knowledge)}: 証明が「あるステートメントが真である」という事実以外のいかなる情報も開示しない。例えば、秘密の入力値を知っていることを証明しても、その秘密の値自体は明かされない。
    \item \textbf{簡潔性 (Succinctness)}: 証明のサイズが非常に小さく、検証時間が短い。これにより、検証コストが重要なブロックチェーンなどの環境に適している。
    \item \textbf{非対話性 (Non-interactive)}: 事前の一度きりのセットアップの後、証明者と検証者の間でインタラクションなしに証明が生成・検証される。
    \textbf{知識の論拠 (ARgument of Knowledge)}: 証明者が実際に秘密の入力（witness）を知っていることを保証する。
\end{itemize}
Groth16は、このようなzk-SNARKsの中でも特に効率的で広く利用されている方式の一つであり、特にその証明サイズの小ささと検証の速さで知られている。
ブロックチェーンのように検証コストが重視される環境において、特に強力な選択肢となる。

Groth16プロトコルは主に3つのアルゴリズムから構成される：
\begin{description}
    \item[Setup] 回路（通常はR1CS形式）から、証明鍵（Proving Key, pk）と検証鍵（Verification Key, vk）を生成する。
    このプロセスは回路ごとに一度だけ実行する必要があり、信頼できる第三者または複数当事者によるセレモニー（Trusted Setup）を必要とする。
    このセットアップで用いられた乱数（"toxic waste"）が漏洩すると、不正な証明が生成可能になるという課題がある。
    \item[Prove] 証明者は、証明鍵、公開入力（witness）、および秘密入力を用いて、証明（proof, $\\pi$）を生成する。
    \item[Verify] 検証者は、検証鍵、公開入力、および証明$\\pi$を受け取り、その正当性を検証する。
\end{description}

Groth16の証明は、特定の楕円曲線（例: BN254）上の3つの群要素（$\\mathbb{G}_1$の元2つ、$\\mathbb{G}_2$の元1つ）で構成され、回路の規模に関わらず常に一定のサイズである。
検証は、数回のペアリング演算によって行われ、極めて高速に完了する。
この効率性の代償として、回路ごとに異なるTrusted Setupが必要であり、汎用性（universality）に欠けるというトレードオフが存在する。
