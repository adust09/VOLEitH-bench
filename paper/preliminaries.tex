\section{前提知識と関連研究}
本章では、本稿で扱う暗号プロトコルとオンチェーン検証の前提、および関連研究を概観する。
計算・ストレージ・データ転送に対して課金されるEthereum上での検証を念頭に、ゼロ知識証明、VOLE、SNARK、関連研究の流れをまとめる。

\subsection{ゼロ知識証明の基礎}
ゼロ知識証明は、証明者が検証者に対し、ある表明が真であることを、その表明の真実性を担保する情報（witness）を一切明かすことなく納得させるためのプロトコルである。
ZKPは以下の3つの性質を満たす必要がある。
\begin{enumerate}
    \item \textbf{完全性 (Completeness)}: 証明者の表明が真であるならば、正直な証明者は正直な検証者を必ず納得させることができる。
    \item \textbf{健全性 (Soundness)}: 証明者の表明が偽であるならば、不正な証明者が正直な検証者を騙して納得させられる確率は、無視できるほど小さい。
    \item \textbf{ゼロ知識性 (Zero-Knowledge)}: 検証者は、証明の正当性以外には、証明者の持つ秘密情報について何も知ることができない。
\end{enumerate}
ZKPは、証明者と検証者の間で複数回のやり取りを必要とする「対話型証明システム」と、証明者が一度証明を公開すれば誰でも検証できる「非対話型証明システム（NIZK）」に大別される。
オンチェーン検証のように、不特定多数の検証者が非同期に検証を行う環境では、NIZKが不可欠となる。

\subsection{VOLE}
VOLE（Vector Oblivious Linear Evaluation）は、二者間（SenderとReceiver）のセキュアな計算プロトコルであり、近年のZKPシステムの効率化に大きく貢献している。
基本的なVOLEプロトコルでは、Senderが持つアフィン変換 \texttt{f(x) = ax + b} と、Receiverが持つベクトル \texttt{u} に対し、Receiverが \texttt{v = au + b} を計算する。
この過程で、Senderは \texttt{u} について、Receiverは \texttt{a, b} について何も知ることができない。

\subsection{VOLE-in-the-Head (VOLEitH)}
VOLE-in-the-Head (VOLEitH) は、VOLEベースのプロトコルをZKPに昇華させた手法である。
その基本的なアイデアは、証明したい算術回路のワイヤ値をProverがコミットし、Verifierがランダムな線形結合をチェックすることで、回路全体の計算が正しく行われたかを検証するというものである。

本研究で利用する\texttt{soft\_spoken}ライブラリは、VOLEitHの具体的な実装の一つである。
\texttt{soft\_spoken}では、SPVOLEとZP-VOLEを巧みに組み合わせることで、効率的な証明生成を実現している。プロトコルの流れは以下のようになる。
\begin{enumerate}
    \item \textbf{コミットメント}: Proverは、算術回路の各ワイヤの値を表すベクトルにコミットする。
    \item \textbf{チャレンジ}: Verifierは、ランダムなチャレンジ（乱数）をProverに送信する。
    \item \textbf{レスポンス}: Proverは、チャレンジに基づき、コミットしたベクトル間の線形関係が成立することを示すための情報を計算し、Verifierに返信する。
    \item \textbf{検証}: Verifierは、Proverからのレスポンスと自身が持つ情報を用いて、線形関係が成立するかをチェックする。もし成立すれば、Proverが回路を正しく計算したと確信する。
\end{enumerate}
この対話型のプロトコルを非対話的にするため、Fiat--Shamir変換が用いられる。
これは、Verifierが生成するランダムなチャレンジを、プロトコルのここまでの情報（コミットメント等）をハッシュ関数に入力することで自己生成するテクニックである。
これにより、ProverはVerifierとの対話なしに証明を一方的に生成でき、生成された証明は誰でも検証可能なNIZKとなる。

\subsection{関連研究}
VOLE-in-the-Head (VOLEitH)は\textbf{MPC-in-the-Head (MPCitH)}と\textbf{QuickSilver}という二つの研究パラダイムから多くの影響を受けている。
以下では、それぞれの系譜とVOLEitHとの接続点を整理する。

\subsubsection{MPC-in-the-Head (MPCitH) フレームワーク}
MPCitHは、セキュア多人数計算のアイデアを識別スキームやZKPoKに転用する枠組みである。

\paragraph{起源と概念}
Ishai、Kushilevitz、Ostrovsky、Sahaiが2007年に提案したMPCitH（Multi-Party Computation in the Head）は、証明者 $P$ が秘密の証拠 $x$ を複数パーティのシェア $[x]_1,\ldots,[x]_N$ に分割し、仮想的なMPCプロトコルを頭の中で実行するというアプローチである。
検証者 $V$ は、ランダムに選んだパーティ $i^*$ を除く全てのビューの開示を要求することで、証拠を知っていることを間接的に確認する。
任意の一方向関数 $F: x \mapsto y$ に対して適用できる汎用性があり、耐量子署名を含む幅広い暗号プロトコル構築に利用されてきた。

\paragraph{VOLEitHが解決するMPCitHの課題}
MPCitHではSoundnessエラーを抑えるためにチャレンジと回答の繰り返し回数を増やす必要があり、Proof-of-Knowledge誤り $2^{-t}$ を達成するには$t$ラウンドのやり取りを要し、証明サイズは $O(t \cdot N)$ に膨らむ。
また証明者は各ラウンドで複数パーティ分のビューを再計算するため、線形演算と一方向関数評価がボトルネックになる。
VOLEitHは、QuickSilver由来のVOLE MACを使って乗算ゲート整合性を一括チェックすることで、MPCitHが抱えていた「多パーティ再現」「広帯域通信」といったオーバーヘッドを回路規模に線形なコストへ圧縮する。
さらに、SoftSpokenOTに代表されるOTリダクションを介して、MPCitHで必須だったビュー整合性証明をVOLEベースの一括生成処理に置き換え、Fiat--Shamir変換後でも短い証明と高速な証明者性能を維持できる。

\subsubsection{QuickSilver: VOLEベースZKPとの統合}
VOLEitHは、Vector Oblivious Linear Evaluation (VOLE) にアクセスできるQuickSilver型のZKPシステムを取り込み、VOLE MACを準同型コミットメントとして扱うことで効率を引き出す。

\paragraph{QuickSilverの構造と特徴}
Yang、Sarkar、Weng、WangによるQuickSilverプロトコルは、VOLEハイブリッドモデルにおける対話型ZKPoKとして提案された。
DittmerらのLine-Point Zero-Knowledgeパラダイムを基盤とし、任意の有限体上の算術回路に対して証明を構成する。
VOLEから得られるタプル $(\mathbf{u}_i,\mathbf{v}_i,\mathbf{q}_i)$ は、グローバルキー $\mathbf{\Delta}$ の下で機能するメッセージ認証コードとなり、準同型性を活かして乗算制約 $\mathbf{w}_\alpha \cdot \mathbf{w}_\beta = \mathbf{w}_\gamma$ を効率的に検証する。
これにより、指定検証者型のVOLEベースZKPが、軽量な検証コストで高いスループットを実現できる。

\subsection{SNARKとオンチェーン検証の概観}
Groth16を例に、オンチェーン検証は以下の処理で構成される。(i) 証明と公開入力をcalldataとして受領する、(ii) 回路固有の検証鍵をコントラクトに格納する、(iii) 公開入力とICベクトルの多倍長加算（MSM）から\(\mathrm{vk\_x}\)を計算する、(iv) ペアリング用precompileを用いて等式成立を判定する。
コストを支配する因子は次の通りである。第一に、ペアリングprecompileが扱える曲線はBN254（alt\_bn128）のみであり、安全性は約100ビットに制約される。第二に、ペアリング呼び出し（通常3回）がガスの大半を占め、1回あたり\(\sim\)34k gas（EIP-1108後）で15--20万gas規模の固定費となる。第三に、公開入力数に応じてMSMが線形に増加し、ガスも\(O(m)\)で伸びる。第四に、calldataの非ゼロバイトは16 gasで課金され、証明サイズ1055バイトの場合でも約1.7万gasを要する。さらに、デプロイ済みコードは24KBに制限されるため、大きな検証鍵を直列に埋め込む設計は困難である。

\subsection{設計指針}
\begin{itemize}
    \item \textbf{証明サイズの固定性}: Groth16の証明サイズは一定であり（本稿では1055バイト）、回路規模が増加してもcalldata課金は増えない。
    \item \textbf{公開入力の削減}: 公開入力数に比例してMSMコストが増えるため、ハッシュ圧縮等で項目数を最小化する。
    \item \textbf{検証鍵の配置}: コントラクトサイズ上限を考慮し、検証鍵を別コントラクトに分離・共有するなどの構成が求められる。
    \item \textbf{フィールド整合性}: 証明生成と検証はBN254に揃える必要があり、異なる曲線を用いる場合は専用プリコンパイルやロールアップ環境を前提とする。
\end{itemize}
