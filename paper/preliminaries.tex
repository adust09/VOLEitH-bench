\section{前提知識と関連研究}
本章では、後続のベンチマークと考察を理解するために必要な暗号学的前提を簡潔に整理する。
\subsection{Vector Oblivious Linear Evaluation (VOLE)}
Vector Oblivious Linear Evaluation（VOLE）は、Oblivious Transfer (OT) の算術形式と見なされる暗号学的プリミティブであり、証明者と検証者の間で、秘密裡に線形代数的な相関関係を確立する二者間プロトコルである。

$k$をセキュリティパラメータ、$\mathbb{F}_{2^k}$を要素数$2^k$の有限体とする。プロトコル完了後、証明者は秘密のベクトル $\mathbf{u} \in \mathbb{F}_2^\ell$ とランダムなVOLEタグ $\mathbf{v} \in \mathbb{F}_{2^k}^\ell$ を保持し、検証者はグローバルキー $\Delta \in \mathbb{F}_{2^k}$ とVOLEキー $\mathbf{q} \in \mathbb{F}_{2^k}^\ell$ を保持する。これらの値は、以下のVOLE相関式を満たす。
\begin{equation}
    q_i = u_i \cdot \Delta + v_i \quad (i=0, \dots, \ell-1)
\end{equation}
この相関は、証明者が持つランダムビット $u_i$ に対する\textbf{線形準同型コミットメントスキーム}として機能する。このコミットメントは以下の性質を持つ。
\begin{description}
    \item[秘匿性 (Hiding)] 検証者は、$q_i$と$\Delta$から$u_i$の情報を得られない。これは、証明者が知るランダムな値$v_i$が$u_i$の値をマスクするためである。
    \item[拘束性 (Binding)] 証明者は、検証者の持つ秘密$\Delta$を知らない限り、一度コミットした$u_i$を不正な値に開示することができない。その成功確率は計算論的に無視できるほど小さい。
\end{description}
VOLEの最も強力な特性は、その線形準同型性にある。同じグローバルキー$\Delta$を持つ複数のVOLE相関 $(u_i, v_i, q_i)$ と公開定数 $c, c_1, \dots, c_n \in \mathbb{F}_{2^k}$ が与えられたとき、証明者と検証者は新しい値 $u' = c + \sum_{i=1}^{n} c_i u_i$ に対するVOLE相関 $(u', v', q')$ を、追加の通信なしにローカルで計算できる。
\begin{description}
    \item[証明者の計算] 証明者は新しいVOLEタグ$v'$を以下のように計算する。
    \begin{equation}
        v' = \sum_{i=1}^{n} c_i v_i
    \end{equation}
    \item[検証者の計算] 検証者は新しいVOLEキー$q'$を以下のように計算する。
    \begin{equation}
        q' = c \cdot \Delta + \sum_{i=1}^{n} c_i q_i
    \end{equation}
\end{description}
VOLEが有するこの強力な線形準同型性は、算術回路の検証コストに直接的な影響を及ぼす。
VOLE相関 ($q_i = u_i \cdot \Delta + v_i$) は、その構造自体が線形な関係式である。そのため、加算やスカラー乗法といった\textbf{線形演算}は、VOLEと高い親和性を持つ。例えば、2つの値に対するVOLE相関が与えられたとき、それらの和に対する新しいVOLE相関は、証明者と検証者がそれぞれ手元で対応する値を足し合わせるだけで構築可能である。これは、線形演算がVOLEの線形構造を保存するためであり、追加の通信を一切要しない。

一方で、乗算のような\textbf{非線形演算}は、この線形構造を破壊する。2つのVOLE相関を乗算しても、その結果が有効なVOLE相関となることはない。そのため、証明者は、自身が正しく乗算を実行したことを検証者に納得させるための、ないしは検証させるための追加のプロトコル、すなわち次節で詳述する\textbf{乗算検定}を実行する必要がある。この検定は、非線形な乗算関係の検証を、追加の通信を伴う線形なチェックへと帰着させるものである。したがって、VOLEベースのゼロ知識証明における主要な計算・通信コストは、この非線形演算を処理するための乗算検定に集約される。

\subsection{VOLE-based ZKと乗算検定}
VOLEの持つ線形性（加法準同型性）を利用することで、効率的なゼロ知識証明プロトコル（VOLE-based ZK）を構築可能である。このパラダイムは、QuickSilver\cite{quicksilver}などのプロトコルで採用されている。VOLEベースの証明は、証明者・検証者ともに極めて高速であるものの、その主要な計算コストは乗算のような非線形演算の検証に集約される。

乗算ゲート、例えば $w_\gamma = w_\alpha \cdot w_\beta$ の検証は、特別な\textbf{乗算検定プロトコル}を必要とする。このプロトコルは、証明者と検証者が保持するVOLE相関が、実際の乗算関係を正しく反映しているかを、検証者の秘密キー$\Delta$を利用して確認するものである。
\begin{description}
    \item[証明者の役割] 証明者は、乗算ゲートに関わる自身の秘密値（$u_\alpha, v_\alpha, u_\beta, v_\beta$など）に基づいて、中間値である$a_0$と$a_1$を計算し、検証者に送信する。
    \item[検証者の役割] 検証者は、自身が持つVOLEキー（$q_\alpha, q_\beta, q_\gamma$）から特定の値$b$を計算する。その後、証明者から受け取った$a_0, a_1$と、自身の秘密キー$\Delta$を用いて、以下の線形な等式が成立するかを検証する。
    \begin{equation}
        b \stackrel{?}{=} a_0 + a_1 \cdot \Delta
    \end{equation}
    このチェックが成功すれば、証明者が正直に計算を行ったことが高い確率で保証される。もし証明者が不正を働いていた場合、この等式を成立させるには$\Delta$の値を推測する必要があり、その成功確率は計算論的に無視できるほど小さい。
\end{description}

しかし、この仕組みは、検証者がグローバルキー$\Delta$の値を秘密に保つことを前提としている。このため、証明を検証できるのが特定の検証者に限定される\textbf{指定検証者証明（Designated Verifier Proof）}となり、第三者が検証できる\textbf{公開検証可能性（Public Verifiability）}を持たないという課題を有していた。

\subsection{VOLE-in-the-Head}
前節で述べた指定検証者問題を解決し、公開検証可能性を実現するものがVOLE-in-the-Head (VOLEitH) と呼ばれるコンパイラである。
VOLEitHは、SoftSpokenOT \cite{softspokenot} のような効率的なVOLE相関生成プロトコルを、MPC-in-the-Head \cite{mpc-in-the-head} の手法と組み合わせることで、非対話かつ公開検証可能な証明を構築する。

VOLEitHの効率性の根幹を支えるのは、\textbf{SoftSpokenOT}\cite{softspokenot}と呼ばれるプロトコルである。これは、少数の高価なベースOT（Oblivious Transfer）から、擬似乱数を用いて極めて多数の安価なOTインスタンスを生成するOT拡張技術の一種である。
特に、相関のある乱数を利用してOTをバッチ処理することに特化しており、VOLE相関を生成する上で必要となる「$N$個のシードの中から、チャレンジで指定された1個のシードを除いた$N-1$個の情報を効率的に転送する」という処理（All-but-One OT）と高い親和性を持つ。
結果として、SoftSpokenOTはVOLEitHにおけるVOLE相関の生成エンジンとして機能し、プロトコル全体の通信・計算コストを大幅に削減する役割を担う。

その核心は、検証者が秘密のグローバルキー$\Delta$を持つ代わりに、証明者自身がプロトコルの中で$\Delta$の元となる情報にコミットし、後からFiat-Shamir変換によってチャレンジとして$\Delta$を導出する点である。
このプロセスは、GGMツリー\cite{ggm}を用いたAll-but-One Oblivious Transferの技術を用いて効率的に実装される。

\paragraph{GGMツリーによるAll-but-Oneコミットメント}

GGMツリー（Goldreich-Goldwasser-Micali Tree）は、短い入力（シード）から長い擬似乱数系列を効率的に生成するための仕組みであり、特に擬似乱数生成器（PRG）を繰り返し適用することで構築される木構造である。
このツリーの各ノードは、親ノードのシードからPRGを用いて計算され、再帰的に展開される。
最終的に最下層に到達した「葉」（リーフノード）には、一連の擬似乱数が対応付けられる。
GGMツリーの重要な特性は、この構造を利用して、ある特定の一つのリーフノード以外の全てのリーフノードの値を効率的に開示できる点にある。この性質が、All-but-Oneコミットメントスキームを構築する上で不可欠となる。

All-but-Oneコミットメントは、コミッターが複数の値の集合（例えば、$N$個の値）に対してコミットメントを行い、後からその集合内の任意の一つの値**以外**の全ての値を公開できる暗号プリミティブである。このとき、公開されなかった一つの値については、コミットメントの受信者には全く情報が漏洩しないことが保証される。

VOLE-in-the-Head (VOLEitH) プロトコルでは、このGGMツリーを用いたAll-but-Oneコミットメントが、特に$N$個のシードの中から、チャレンジで指定された1個のシードを除いた$N-1$個の情報を効率的に転送する（All-but-One OTの文脈で）ために利用される。
これにより、検証者が秘密のグローバルキー$\Delta$を持つ代わりに、証明者自身が$\Delta$の元となる情報にコミットし、公開検証可能性を実現する。

プロトコルは以下のように進行する。
\begin{description}
    \item[ステップ1: GGMツリー構築とコミットメント]
    まず、セキュリティパラメータ$\lambda$に対して、入力シードを2倍の長さの出力に拡張する擬似乱数生成器 (PRG) $G: \{0,1\}^\lambda \to \{0,1\}^{2\lambda}$ を定義し、$G(s) = (s_0, s_1)$ とする。証明者は、ランダムなルートシード$s_{root} \in \{0,1\}^\lambda$を選択する。
    深さ$d = \log N$のGGMツリーは、このルートシードからPRGを再帰的に適用することで構築される。各ノードは、その親ノード$s_{parent}$から$G(s_{parent})$によって2つの子ノードシード（$s_0, s_1$）が生成される形で展開される。具体的には、インデックス$i \in \{0, \ldots, N-1\}$の$d$ビット表現を$i_1i_2\dots i_d$とすると、リーフ（葉）シード$sd_i$は、ルートからパス$i_1\dots i_d$を辿って$sd_i = s_{i_1\dots i_d}$として計算される。
    証明者は、こうして得られた$N$個の全てのリーフシード$\{sd_i\}_{i=0}^{N-1}$に対してハッシュ関数$H$を適用し、ハッシュ値$h_{com}=H(sd_0, \ldots, sd_{N-1})$を計算して、これをコミットメントとして公開する。

    \item[ステップ2: VOLE値の計算]
    証明者は、各リーフシード$sd_i$をさらに別のPRG（$G'$とする）で展開してランダムな文字列$r_i = G'(sd_i)$を得て、自身の秘密VOLE値$\mathbf{u}, \mathbf{v}$を以下のように計算する。
    \begin{align}
        \mathbf{u} &= \sum_{i=0}^{N-1} r_i \\
        \mathbf{v} &= \sum_{i=0}^{N-1} i \cdot r_i
    \end{align}

    \item[ステップ3: チャレンジと開示 (All-but-One OT)]
    証明の主要部分が構成された後、Fiat-Shamir変換により、証明全体のトランスクリプトからチャレンジ$\Delta \in \{0, \ldots, N-1\}$が導出される。この$\Delta$が開示を免除される（すなわち秘匿される）インデックスとなる。
    証明者は、GGMツリーにおいて$sd_\Delta$を隠したまま残りの全てのシードを開示するため、ルートから$sd_\Delta$に至るパス上の各ノードの\textbf{兄弟ノード}（sibling node）のシードを開示情報$pdecom$として証明に含める。$\Delta$のビット表現を$\Delta_1\dots\Delta_d$とすると、$pdecom$は以下の$\log N$個のシードの集合である。
    \begin{equation}
        pdecom = \{ s_{\Delta_1\dots\Delta_{j-1}\bar{\Delta}_j} \}_{j=1}^d, \quad \text{ここで } \bar{\Delta}_j = 1-\Delta_j
    \end{equation}
    この$pdecom$に含まれる兄弟ノードのシードは、$\Delta$に続くパスとは異なる全てのパスを再構築するのに必要な情報を提供する。

    \item[ステップ4: 検証]
    検証者は、まず証明者と同様にFiat-Shamir変換で$\Delta$を導出する。次に、$pdecom$に含まれる$\log N$個の兄弟ノードのシードを用いて、$\Delta$以外の全てのインデックス$i \neq \Delta$に対応するリーフシード$sd_i$を再計算する。この再計算が可能であるのは、$i$と$\Delta$のビット表現が最初に異なる位置を$j$とすると、$sd_i$の計算に必要なプレフィックス$i_1\dots i_j$を持つノードのシードが$pdecom$に含まれる$s_{\Delta_1\dots\Delta_{j-1}\bar{\Delta}_j}$（ここで $i_j = \bar{\Delta}_j$）から計算を開始できるためである。
    検証者は、復元した$N-1$個のリーフシードと、公開されている$h_{com}$が正しく再構成できることを確認し、開示の正当性を検証する。最後に、これらのシードと$\Delta$を用いてVOLEキー$\mathbf{q}$を計算し、VOLE相関$q_i = u_i \Delta + v_i$の検証へと進む。
\end{description}

\subsection{Groth16}
まず、Groth16を理解するために、zk-SNARKs（zero-knowledge Succinct Non-interactive ARguments of Knowledge）について説明する。
zk-SNARKsは、以下の性質を持つ暗号学的証明システムである。
\begin{itemize}
    \item \textbf{ゼロ知識 (Zero-Knowledge)}: 証明が「あるステートメントが真である」という事実以外のいかなる情報も開示しない。例えば、秘密の入力値を知っていることを証明しても、その秘密の値自体は明かされない。
    \item \textbf{簡潔性 (Succinctness)}: 証明のサイズが非常に小さく、検証時間が短い。これにより、検証コストが重要なブロックチェーンなどの環境に適している。
    \item \textbf{非対話性 (Non-interactive)}: 事前の一度きりのセットアップの後、証明者と検証者の間でインタラクションなしに証明が生成・検証される。
    \textbf{知識の論拠 (ARgument of Knowledge)}: 証明者が実際に秘密の入力（witness）を知っていることを保証する。
\end{itemize}
Groth16は、このようなzk-SNARKsの中でも特に効率的で広く利用されている方式の一つであり、特にその証明サイズの小ささと検証の速さで知られている。
ブロックチェーンのように検証コストが重視される環境においては、特に強力な選択肢となる。

Groth16プロトコルは主に3つのアルゴリズムから構成される：
\begin{description}
    \item[Setup] 回路（通常はR1CS形式）から、証明鍵（Proving Key, pk）と検証鍵（Verification Key, vk）を生成する。
    このプロセスは回路ごとに一度だけ実行する必要があり、信頼できる第三者または複数当事者によるセレモニー（Trusted Setup）を必要とする。
    このセットアップで用いられた乱数（"toxic waste"）が漏洩すると、不正な証明が生成可能になるという課題がある。
    \item[Prove] 証明者は、証明鍵、公開入力（witness）、および秘密入力を用いて、証明（proof, $\\pi$）を生成する。
    \item[Verify] 検証者は、検証鍵、公開入力、および証明$\\pi$を受け取り、その正当性を検証する。
\end{description}

Groth16の証明は、特定の楕円曲線（例: BN254）上の3つの群要素（$\\mathbb{G}_1$の元2つ、$\\mathbb{G}_2$の元1つ）で構成され、回路の規模に関わらず常に一定のサイズである。
検証は、数回のペアリング演算によって行われ、極めて高速に完了する。
この効率性の代償として、回路ごとに異なるTrusted Setupが必要であり、汎用性（universality）に欠けるというトレードオフが存在する。
