\section{前提知識と関連研究}
本章では、後続のベンチマークと考察を理解するために必要な暗号学的前提を簡潔に整理する。

\subsection{Vector Oblivious Linear Evaluation (VOLE)}
VOLEは、二者間で線形関係を隠したままMAC相関を生成するプリミティブである。
有限体 $F$ 上で、送信者はベクトル $\mathbf{u}, \mathbf{v} \in F^m$ を、受信者はグローバル鍵 $\mathbf{\Delta} \in F^m$ を入力とする。
プロトコル終了後、受信者は
\begin{equation}
    \mathbf{q} = \mathbf{u} \circ \mathbf{\Delta} - \mathbf{v} \in F^m
\end{equation}
を満たすペア $(\mathbf{u}, \mathbf{q})$ を得る（$\circ$ は要素積）。
$\mathbf{q}$ は $\mathbf{u}$ に対する情報理論的MACとなり、$\mathbf{\Delta}$ を知らずに $\mathbf{q}$ を固定したまま $\mathbf{u}$ を改ざんすることはできない（binding）。
この性質が後述の健全性担保に直接利用される。

一般的に、入力 $\mathbf{u}$ を $\mathbb{F}_2$ に制限しつつ、$\mathbf{v}, \mathbf{q}, \mathbf{\Delta}$ を拡大体 $\mathbb{F}_{2^\lambda}$ 上に置くサブフィールドVOLEが用いられる。
これはビット演算を保ちつつ、MACは大きな体で保持することで効率と安全性を両立するためである。

\subsection{VOLE-based ZK}
todo

\subsection{VOLE-in-the-Head}
VOLEitHは、MPC-in-the-Headの開示構造にQuickSilver型のVOLE検査を組み込み、指定検証者型VOLEを公開検証可能に拡張した手法である。
VOLEitHは、MPCitHの「開示しない1パーティ」を、VOLEのグローバル鍵 $\mathbf{\Delta}$ に対応付けることで、指定検証者型のVOLE系プロトコルを公開検証可能にする。
鍵となるのが、長さ倍増PRGから構成するGGM treeに基づく All-but-One Vector Commitmentである。
\begin{itemize}
    \item 高さ $h=\log N$ のGGM木の根シードから $N$ 個の葉シード $sd_i$ を生成し、各葉にVOLE用の乱数列 $r_i$ を割り当てる。
    \item 開示しないインデックス $j^*$ を除き、$P$ は各葉への経路で必要な兄弟ノードのシードを開示するだけで $N-1$ 個の $r_i$ を再現させられる（通信量は $O(\log N)$）。
    \item 開示されない $r_{j^*}$ が $\mathbf{\Delta}$ に対応し、$V$ は公開された $r_i$ の線形結合から $\mathbf{q}=\mathbf{u}\circ\mathbf{\Delta}-\mathbf{v}$ を再構成する。
\end{itemize}
この構成により、OTを用いずに非対話でVOLE相関を生成し、MACのbinding性を保ったままFiat--Shamir変換を適用できる。

\subsection{Groth16}
Groth16は、現在最も広く利用されているzk-SNARKsの一つであり、特にその証明サイズの小ささと検証の速さで知られている。
ブロックチェーンのように検証コストが重視される環境において、特に強力な選択肢となる。

Groth16プロトコルは主に3つのアルゴリズムから構成される：
\begin{description}
    \item[Setup] 回路（通常はR1CS形式）から、証明鍵（Proving Key, pk）と検証鍵（Verification Key, vk）を生成する。
    このプロセスは回路ごとに一度だけ実行する必要があり、信頼できる第三者または複数当事者によるセレモニー（Trusted Setup）を必要とする。
    このセットアップで用いられた乱数（"toxic waste"）が漏洩すると、不正な証明が生成可能になるという課題がある。
    \item[Prove] 証明者は、証明鍵、公開入力（witness）、および秘密入力を用いて、証明（proof, $\pi$）を生成する。
    \item[Verify] 検証者は、検証鍵、公開入力、および証明$\pi$を受け取り、その正当性を検証する。
\end{description}

Groth16の証明は、特定の楕円曲線（例: BN254）上の3つの群要素（$\mathbb{G}_1$の元2つ、$\mathbb{G}_2$の元1つ）で構成され、回路の規模に関わらず常に一定のサイズである。
検証は、数回のペアリング演算によって行われ、極めて高速に完了する。
この効率性の代償として、回路ごとに異なるTrusted Setupが必要であり、汎用性（universality）に欠けるというトレードオフが存在する。


\subsection{オンチェーン検証}
オンチェーン検証とは、ブロックチェーン上で暗号学的証明の正当性を検証するプロセスを指す。本稿では特に、Ethereum仮想マシン（EVM）上でzk-SNARKの証明を検証するケースを扱う。

Ethereumは、\textbf{スマートコントラクト}と呼ばれるプログラムを実行できる分散型プラットフォームである。
スマートコントラクトは一度デプロイされると、そのロジックは誰でも呼び出すことができ、実行結果はブロックチェーンに記録され、改ざんが困難となる。
しかし、スマートコントラクトの実行には\textbf{ガス}と呼ばれる手数料が必要であり、計算が複雑であるほど高額になる。
このため、オンチェーンでの利用には、検証コストが極めて低い証明システムが不可欠となる。

この文脈でGroth16が広く採用されるのは、その\textbf{証明サイズが小さい}（回路の規模に関わらず一定かつBN254曲線で約1KBと非常に小さい）点と、\textbf{検証が高速}である点にある。
ブロックチェーンに送信するデータ（calldata）や計算はガス代に直結するため、これらの特性はオンチェーン検証の経済性を大きく左右する。

Ethereum上でGroth16の証明を検証するには、Solidityで記述された検証コントラクトが用いられる。
この検証ロジックは、Ethereumに予め組み込まれた\textbf{プリコンパイル済みコントラクト}を利用することで、効率的に実行される。
具体的には、アドレス`0x08`に配置された`ecPairing`というプリコンパイル済みコントラクトが、BN254曲線におけるペアリング演算をネイティブ実装に近い速度で提供する。

検証のプロセスは以下の通りである。
まず、開発者は証明対象の回路に対応する検証鍵（Verification Key, vk）を含むスマートコントラクト（例: Verifier.sol）をEthereumにデプロイする。
次に、証明を検証したいユーザーは、証明（proof, $\pi$）と公開入力（public inputs）をトランザクションとして検証コントラクトに送信する。
検証コントラクトは、受け取った証明と公開入力、そしてコントラクト内に保管された検証鍵を用いてGroth16の検証方程式を評価する。
この際、高コストなペアリング演算は`ecPairing`プリコンパイル済みコントラクトを呼び出して実行し、方程式が成立すれば証明は正当であると判定される。
この結果に基づき、コントラクトは後続の処理（状態の更新や別のコントラクト呼び出しなど）を行う。

このようなオンチェーンZKアプリケーション開発において、\textbf{Circom}は算術回路を記述するためのドメイン固有言語（DSL）であり、そのツールチェーン（`snarkjs`を含む）は、回路記述の容易さに加え、コンパイルされた回路からGroth16の検証鍵を抽出し、それに基づいた\textbf{Solidity製の検証コントラクト（`Verifier.sol`）を自動生成する機能}を持つ。
これにより、開発者は複雑なペアリング演算のロジックを自ら実装することなく、効率的にオンチェーン検証用のスマートコントラクトを準備することが可能となる。
